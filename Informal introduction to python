
Python introduction

Input and output distinguished by presence or absence of prompt
(>>> and …)

You must type everything after prompt, when prompt appear.

Lines do not begin with prompt are output from interpreter.


Comments in python begin with #

You can use terminal as calculator 
  e.g:-  2 + 2 	   (50 - 5*6) / 4


Integer Number  (2,4,20) has type int..     Fractional number (5.0,1.6) have type float


Division ( / ) return float
Floor Division ( // ) discard the fractional part
( % ) return remainder of the division

Number = Flored quotient * divisor + remainder


To calculate power :-            5 ** 2 = 5 raise to power of 2
          5 ** 7 = 5 raise to power of 7


If a variable is not “defined” (assigned a value), trying to use it will give you an error:

   Variable name is not defined

In interactive mode the last printed expression is assigned to the variable  _ . 

    >>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06

The variable _ is read only. Do not explicitly assign value


String     Python can also manipulate strings, which can be expressed in several ways. They can be enclosed in a single quote (‘…’) or double quote (“ …. “)

\ used as escape character

>>> 'spam eggs'  # single quotes
'spam eggs'
>>> 'doesn\'t'  # use \' to escape the single quote...
"doesn't"
>>> "doesn't"  # ...or use double quotes instead
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'


If you don’t wait character prefaced by \ to be interpreted as special character, you can use raw string by adding r before the first quote

>>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name


String literal can span multiple lines. One way is using triple quotes “””…”””    or ‘’’….’’’   End of lines are automatically included in the string

It’s possible to prevent this by adding a \ at the end of line
  

String can be concatenated with + operator and repeated with *

  >>> # 3 times 'un', followed by 'ium'
>>> 3 * 'un' + 'ium'
'unununium'

Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated.

>>> 'Py' 'thon'
'Python'


This feature is particularly useful when you want to break long strings:

>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'


Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type; a character is simply a string of size one:

>>> word = 'Python'
>>> word[0]  # character in position 0
'P'
>>> word[5]  # character in position 5
'n'

Indices may also be negative numbers, to start counting from the right:

>>> word[-1]  # last character
'n'
>>> word[-2]  # second-last character
'o'
>>> word[-6]
'P'


Slicing allows you to obtain substring
     
    Word = “Python”
    Word[0:2]  # characters from position 0 (included) to 2 (excluded)
     ‘Py’

     Word[2:5] # characters from position 2 (included) to 5 (excluded)
      ‘Tho’

Now how to start is always included and the end is always excluded 
This make sure that s[:i] + s[I:] always give s

word[:2] + word[2:]
  Pyhton


Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the string being sliced.

>>> word[:2]   # character from the beginning to position 2 (excluded)
'Py'
>>> word[4:]   # characters from position 4 (included) to the end
'on'
>>> word[-2:]  # characters from the second-last (included) to the end
'on'


Attempting to use an index that is too large will result in an error:
>>> word[42]  # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range


However, out of range slice indexes are handled gracefully when used for slicing:

>>> word[4:42]
'on'
>>> word[42:]
''

Pyhton strings can not be changed - they are immutable. Therefore assigning to an index position in the string results in an error

   >>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment


If you need a different string, you should create a new one:
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'


The built-in function len() returns the length of a string:
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34


Python knows a number of compound data types, used to group together other values. The most versatile is the list, which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items of different types, but usually the items all have the same type


>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]


Like strings (and all other built-in sequence types), lists can be indexed and sliced:

>>> squares[0]  # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:]  # slicing returns a new list
[9, 16, 25]



All slice operations return a new list containing the requested elements. This means that the following slice returns a shallow copy of the list:
>>>
 squares[:]
[1, 4, 9, 16, 25]


Lists also support operations like concatenation:
 >>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:

>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
>>> 4 ** 3  # the cube of 4 is 64, not 65!
64
>>> cubes[3] = 64  # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]


You can also add new items at the end of the list, by using the append()

>>> cubes.append(216)  # add the cube of 6
>>> cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]


Assignment to slices is also possible, and this can even change the size of the list or clear it entirely:

>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # replace some values
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # now remove them
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # clear the list by replacing all the elements with an empty list
>>> letters[:] = []
>>> letters
[]


The built-in function len() also applies to lists:

>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4


It is possible to nest lists (create lists containing other lists), for example:

>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'


 First Steps Towards Programming
		
		>>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8


Footnotes

Since ** has higher precedence than -, -3**2 will be interpreted as -(3**2) and thus result in -9. To avoid this and get 9, you can use (-3)**2.


Unlike other languages, special characters such as \n have the same meaning with both single ('...') and double ("...") quotes. The only difference between the two is that within single quotes you don’t need to escape " (but you have to escape \') and vice versa.






See also : - 
    
	Strings : - 

     Text Sequence Type - str
	Stings are examples of sequence type and support the common operations supported by such types


Text Sequence Type — str


String literals that are part of a single expression and have only whitespace between them will be implicitly converted to a single string literal. That is, ("spam " "eggs") == "spam eggs".



String Methods

 	Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting).


	printf-style String Formatting

	String objects have one unique built-in operation: the % operator (modulo). This is also known as the string formatting or interpolation operator.


print('%(language)s has %(number)03d quote types.' %
...       {'language': "Python", "number": 2})
Python has 002 quote types.



str.capitalize()
Return a copy of the string with its first character capitalized and the rest lowercased.
Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character.


str.casefold()
Return a casefolded copy of the string. Casefolded strings may be used for caseless matching.
Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'ß' is equivalent to "ss". Since it is already lowercase, lower() would do nothing to 'ß'; casefold() converts it to "ss".
The casefolding algorithm is described in section 3.13 of the Unicode Standard.

	>>> language = "PyThOn"
	>>> language.casefold()
	'python'
	>>> 


str.center(width[, fillchar])
Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s).

str = "this is string example....wow!!!"
print ("str.center(40, 'a') : ", str.center(40, 'a'))


str.count(sub[, start[, end]])
Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.

>>> str = "this is string example...wow!!!"
	>>> sub = 'i'
>>> str.count(sub)
3
>>> str.count(sub,0,10)
2


str.encode(encoding="utf-8", errors="strict")
Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError.
	
	import base64

Str = "this is string example....wow!!!"
Str = base64.b64encode(Str.encode('utf-8',errors = 'strict'))

print ("Encoded String: " , Str)
 
	Encoded String: b'dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE='


str.endswith(suffix[, start[, end]])
Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.


	>>> str = "Python"
>>> str.endswith('n')
True


>>> str.endswith('t',1,3)
True

str.expandtabs(tabsize=8)
Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\n) or return (\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed.

>>> print("This\tis\tthe\texample")
This	is	the	example
>>> str.expandtabs()
'This    is      the     example'
>>> str.expandtabs(4)
'This    is  the example'
>>> str.expandtabs(2)
'This  is  the example'
>>> 



str.find(sub[, start[, end]])

	Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found.


	>>> str = 'Pyhton'
>>> str.find('th')
-1
>>> str.find('ht')
2

	 The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator:


str.format(*args, **kwargs)
Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}.

	"The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'




str.index(sub[, start[, end]])
Like find(), but raise ValueError when the substring is not found.


str.isalnum()
Return True if all characters in the string are alphanumeric and there is at least one character


str.isalpha()
Return True if all characters in the string are alphabetic and there is at least one character


str.isdecimal()
Return True if all characters in the string are decimal characters and there is at least one character, False otherwise.

>>> str = "1.32332"
>>> str.isdecimal()
False
>>> str = "132332"
>>> str.isdecimal()
True
>>> 


As you can see, main difference between the function str. ... isdigit() is that: the function str. isdecimal() return True only for numbers from 0 to 9, at the same time the function str. isdigit() return True for some other unicode-supported chars.


str.isidentifier()
Return True if the string is a valid identifier according to the language definition, section Identifiers and keywords.
Call keyword.iskeyword() to test whether string s is a reserved identifier, such as def and class.

str.islower()
Return True if all cased characters in the string are lowercase and there is at least one cased character, False otherwise

str.isprintable()

str.isspace()

str.istitle()

str.isupper()


String join()

Join all items in a tuple into a string, using a hash character as separator:



>>> myTuple = ("John","Peter")
>>> x = "#".join(myTuple)
>>> print(x)
John#Peter
>>> myDict = {"name":"John","country":"Norway"}
>>> sp = "test"
>>> sp.join(myDict)
'nametestcountry'
>>> 


str.ljust(width[, fillchar])
Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s).



>>> str.ljust(20,'a')
'This is the stringaa'
>>> str.rjust(20,'a')
'aaThis is the string'
>>> 






